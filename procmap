#!/bin/bash
# procmap
# https://github.com/kaiwan/vasu_grapher.git
#
# Part of the 'procmap' project.
# This bash script forms the userspace component of the 'procmap' project.
#
# The procmap project's intention is simply this: given a process's PID, it will
# display (in a CLI/console output format only for now) a complete 'memory map'
# of the process VAS (virtual address space).
# The memory map will consist of two major parts, ordered by descending virtual
# address:
#
#  Kernel VAS / kernel segment
#  Userspace mappings (or segments)
#
# The kernel segment details will be realized by inserting (insmod(8)) the kernel
# component of this project, the LKM (Loadable Kernel Module) named procmap. It's
# output will then be parsed in and 'drawn' first.
#
# The usermode mappings (or 'segments') will be realized and displayed by the
# majority of the code of this bash script.
#
# Thus, we obtain a full 'picture', a COMPLETE MEMORY MAP of the given process's
# VAS (Virtual Address Space)!
# 
# Common terms:
#  kva = kernel virtual address
#  uva =   user virtual address
#
# Note:- BSD has a utility by the same name: procmap(1), this project isn't
# the same, though (quite obviously) some aspects are similar.
#  (it's man page: https://man.openbsd.org/procmap.1)
#
# Project URL:
# https://github.com/kaiwan/procmap
#
# Run this program; it invokes the other scripts as required.
# Author:
# Kaiwan N Billimoria
# kaiwan -at- kaiwantech -dot- com
# kaiwan -dot- billimoria -at- gmail -dot- com
# kaiwanTECH
#
# License: MIT.
name=$(basename $0)
PFX=$(dirname $(which $0))    # dir in which this script and tools reside
source ${PFX}/config || {
 echo "${name}: fatal: could not source configuration in file '${PFX}/config', aborting..."
 exit 1
}
source ${PFX}/lib_procmap.sh || {
 echo "${name}: fatal: could not source ${PFX}/lib_procmap.sh , aborting..."
 exit 1
}

logfile_post_process()
{
sed -i.bkp "/###\:\:\:/d" ${1}  # take a backup & get rid of the signature line
sed -i "s/\x1b....//g" ${1}    # get rid of the ^[(B^[[m characters !
      # '\x1b' is ESC ! Find it, and then delete it and the following 4 chars
      # (the 4 .'s that follow specify this)
sed -i "s/\x1m.//g" ${1}
# get rid of the color characters !
sed -i "s/^\;166m//g" ${1}
sed -i "s/^mm//g" ${1}
sed -i "s/^5\;166m//g" ${1}
sed -i "s/47m//g" ${1}
}

usage()
{
 cat << @EOF@
Usage: ${name} [options] -p PID-to-show-memory-map-of

Options:
 -u : show ONLY the usermode mappings or segments (not kernel VAS)
 -k : show ONLY the kernel-space mappings or segments (not user VAS)
  [default is to show BOTH]
 -v : verbose mode (try it!)
 -d : debug mode

-----------------------------
Caveats / Limitations:
-----------------------------
- This utility is in the early stages of development and is continually
  evolving. As of now, in terms of the precise arch-specific kernel
  memory layout specifics, it's almost certaily incomplete. For example, as of
  now we don't (can't?) show every kernel mapping as documented in the kernel
  (for the x86_64, here: Documentation/x86/x86_64/mm.rst); f.e., the kernel
  vmemmap region, guard hole, etc are not shown explcitly - they are simply
  within one of the sparse regions on the map

- procmap currently supports the following CPu arch's:
    x86_64, Aarch32
  I intend to support x86-32, Aarch64 shortly; other archs - could use help

- Kernel mappings: the precise 'mode' (perms) of each mapping being unclear (to
  me), I simply put in what seems logical (but am unsure of it's accuracy).
  Knowledgeable persons, pl help!

@EOF@
 1>&2
}


#--- 'main' here

[ $# -lt 2 ] && {
 usage
 exit 1
}

PID=0
while getopts "p:h?ukdv" opt; do
    case "${opt}" in
	h|\?) usage ; exit 0
		;;
        p)
	    PID=${OPTARG}
	    #echo "-p passed; PID=${PID}"
            ;;
        u)
	    echo "[i] -u: will display ONLY user VAS"
		SHOW_KERNELSEG=0
            ;;
        k)
	    echo "[i] -k: will display ONLY kernel VAS"
		SHOW_USERSPACE=0
            ;;
        d)
	    export DEBUG=1
	    echo "[i] -d: running in DEBUG mode"
            ;;
        v)
	    export VERBOSE=1
	    echo "[i] -v: running in VERBOSE mode"
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

[ ${PID} -eq 0 ] && {
 echo "Specifying the PID with -p is mandatory"
 usage
 exit 1
}

PFX=$(dirname $(which $0))    # dir in which 'vasu_grapher' and tools reside
[ ! -f ${PFX}/do_vgraph.sh ] && {
 echo "${name}: ${PFX}/do_vgraph.sh missing? Aborting..."
 exit 1
}
[ ! -f ${PFX}/prep_mapsfile.sh ] && {
 echo "${name}: ${PFX}/prep_mapsfile.sh missing? Aborting..."
 exit 1
}
# Check for process existence
sudo kill -0 ${PID} >/dev/null 2>&1 || {
 echo "${name}: process with PID \"${PID}\" invalid (or dead now?) Aborting..."
 exit 1
}
# Verify it's not a kernel thread
sudo readlink /proc/${PID}/exe >/dev/null || {
 echo "${name}: process with PID \"${PID}\" invalid; I believe it's a kernel thread. Aborting..."
 exit 1
}

LOG=log_procmap.txt
TMPCSV=/tmp/vgrph.csv

init_kernel_lkm_get_details |tee -a ${LOG}
get_machine_type |tee -a ${LOG}

# Invoke the prep_mapsfile script to prep the memory map file
${PFX}/prep_mapsfile.sh ${PID} ${TMPCSV} || exit 1

source ${ARCHFILE}
if [ "${ARCH}" = "Aarch32" ]; then
   sed --in-place '1d' ${TMPCSV}  # rm 1st line [vectors] mapping
fi

# Invoke the worker script to 'draw' the memory map
#  Usage: do_vgraph [-s] [-d] -p PID-of-process -f input-CSV-filename(5 column format)
#  -v : run in verbose mode
#  -d : run in debug mode"
dovg_cmdline="-p ${PID} -f ${TMPCSV}"
[ ${DEBUG} -eq 1 ] && dovg_cmdline="${dovg_cmdline} -d"
[ ${VERBOSE} -eq 1 ] && dovg_cmdline="${dovg_cmdline} -v"
[ ${SHOW_KERNELSEG} -eq 1 ] && dovg_cmdline="${dovg_cmdline} -k"
[ ${SHOW_USERSPACE} -eq 1 ] && dovg_cmdline="${dovg_cmdline} -u"

${PFX}/do_vgraph.sh ${dovg_cmdline} | tee -a ${LOG} 

[ ${DEBUG} -eq 0 ] && rm -f ${TMPCSV}
logfile_post_process ${LOG}
echo "$(date): output logged (appended) here :"
ls -lh ${LOG}
exit 0
